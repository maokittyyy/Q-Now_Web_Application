<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Q-now | Appointment Management</title>
<style>
  :root{
    --primary:#0077cc;--primary-dark:#005fa3;--accent:#00aaff;
    --light-bg:#f5f7fa;--card-bg:#ffffff;--text:#333;--text-light:#555;
    --shadow:0 4px 8px rgba(0,0,0,0.08);--radius:10px;--transition:all .25s ease;
  }
  body{ margin:0; font-family:'Segoe UI',Arial,sans-serif; background:var(--light-bg); color:var(--text); }
  header{ background:var(--primary); color:#fff; padding:15px 20px; display:flex; justify-content:space-between; align-items:center; box-shadow:var(--shadow); }
  header h1{ margin:0; font-size:1.3rem; }
  nav a{ color:#fff; margin-left:20px; text-decoration:none; font-weight:500; transition:var(--transition); }
  nav a:hover{ color:var(--accent); transform:translateY(-2px); }

  .container{ max-width:1100px; margin:30px auto; padding:25px; background:var(--card-bg); border-radius:var(--radius); box-shadow:var(--shadow); }
  h2{ color:var(--primary-dark); margin-top:0; }
  h3{ color:var(--text-light); margin-bottom:8px; }
  .schedule{ overflow-x:auto; margin-top:12px; }
  table{ border-collapse:collapse; width:100%; min-width:680px; border-radius:var(--radius); overflow:hidden; }
  th,td{ border:1px solid #ddd; padding:8px; text-align:center; vertical-align:middle; word-break:break-word; }
  th{ background:var(--primary); color:#fff; font-weight:600; }
  td.empty{ background:#f9f9f9; cursor:pointer; transition:var(--transition); }
  td.empty:hover{ background:#eef6ff; }
  td.booked{ background:#d4edda; cursor:pointer; transition:var(--transition); }
  td.booked:hover{ background:#c3e6cb; }
  table td:first-child, table th:first-child{ width:120px; text-align:left; padding-left:10px; font-weight:bold; background:#f0f4f8; }

  .pending-card, .appt-card{ border:1px solid #ddd; background:#fff8e1; padding:12px; margin:10px 0; border-radius:var(--radius); box-shadow:var(--shadow); transition:var(--transition);}
  .pending-card:hover, .appt-card:hover{ transform:translateY(-3px); box-shadow:0 6px 12px rgba(0,0,0,0.1);}
  .patient-meta,.est-meta{ font-size:0.9rem; color:var(--text-light); line-height:1.4; }
  .est-meta{ margin-bottom:10px; }
  .btn{ padding:8px 14px; border-radius:6px; border:none; cursor:pointer; margin-right:6px; font-weight:500; transition:var(--transition); }
  .btn-accept{ background:var(--primary); color:#fff; }
  .btn-reject{ background:#dc3545; color:#fff; }
  .btn-confirm{ background:#28a745; color:#fff; margin-top:8px; }
  .btn-reschedule{ background:#ff9800; color:#fff; }
  .small{ font-size:0.85rem; color:#666; }
  /* overlay is visually present but doesn't block clicks to the grid.
     dialog keeps pointer events enabled so its buttons work. */
  .overlay {
  position: fixed; 
  left:0; top:0; right:0; bottom:0; 
  background: rgba(0,0,0,0.35);
  display: flex; 
  align-items:center; 
  justify-content:center;
  pointer-events: auto;  /* allow clicks inside overlay and modal */
  z-index: 5000;          /* ensure overlay below confirm button */
}
  .dialog{ background:#fff; padding:18px; border-radius:10px; width:560px; max-width:90%;
    box-shadow:0 10px 30px rgba(0,0,0,0.3);
    pointer-events:auto; /* dialog clickable */
  }
  .dialog h4{ margin:0 0 8px 0; }
  .dialog .row{ margin-top:10px; display:flex; gap:8px; align-items:center; }
  .dialog button{ margin-left:auto; }
  .outline-selected{ outline:3px solid var(--primary); }
  .muted{ opacity:0.7; }

  #confirmSelectionBtn {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 10000;
  display: none;         /* initially hidden */
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  pointer-events: auto;  /* just to be explicit */
}
</style>
</head>
<body>
<header>
  <h1>Appointments</h1>
  <nav>
    <a href="Q-Now.html">Home</a>
    <a href="Live_Queue.html">Live Queue</a>
    <a href="Analytics.html">Analytics</a>
    <a href="Search.html">Search Database</a>
  </nav>
</header>

<div class="container" id="establishmentsContainer">
  <h2>Loading your establishments...</h2>
</div>

<button id="confirmSelectionBtn" class="btn btn-confirm">Confirm Selection</button>


<!-- modal (non-blocking) -->
<div id="modalOverlay" style="display:none;" class="overlay" role="dialog" aria-hidden="true">
  <div class="dialog" id="modalDialog" aria-modal="false">
    <h4 id="modalTitle">Select slots</h4>
    <div id="modalBody" class="small"></div>
    <div class="row">
      <button id="modalCancel" class="btn">Cancel</button>
      <button id="modalProceed" class="btn btn-confirm">Proceed</button>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
import { getDatabase, ref, onValue, update, push } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyA-VDEzKeVVpOwE7rds6ofNsKvxK3mWIlE",
  authDomain: "q-now-7d98a.firebaseapp.com",
  databaseURL: "https://q-now-7d98a-default-rtdb.asia-southeast1.firebasedatabase.app/",
  projectId: "q-now-7d98a",
  storageBucket: "q-now-7d98a.app",
  messagingSenderId: "72096271594",
  appId: "1:72096271594:web:b86777a11af444aac49b93"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);
const tz = "Asia/Manila";

// UI elements
const container = document.getElementById("establishmentsContainer");
const modalOverlay = document.getElementById("modalOverlay");
const modalTitle = document.getElementById("modalTitle");
const modalBody = document.getElementById("modalBody");
const modalCancel = document.getElementById("modalCancel");
const modalProceed = document.getElementById("modalProceed");
const confirmBtn = document.getElementById("confirmSelectionBtn");

/// state
let cellMaps = {};
let appointmentCache = {};
let activeSelection = [];
let activeApptContext = null;
let selectionMode = null;

// helpers
function normalizeSlots(slots){ return slots ? (Array.isArray(slots) ? slots : Object.values(slots)) : []; }
function escapeHtml(s){ if(!s && s!==0) return ""; return String(s).replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[m])); }
function createButton(cls,label,fn){ const b=document.createElement("button"); b.className=`btn ${cls}`; b.textContent=label; b.onclick=fn; return b; }
confirmBtn.addEventListener("click", confirmSelection);

function toMinutes(t){ const [h,m] = t.split(":").map(Number); return h*60+m; }
function areSlotsConsecutive(slots){ if(!slots.length) return false; const date=slots[0].date; if(!slots.every(s=>s.date===date)) return false; const times=slots.map(s=>s.time).sort(); for(let i=1;i<times.length;i++){ if(toMinutes(times[i])-toMinutes(times[i-1])!==30) return false; } return true; }

// auth + top-level listeners
onAuthStateChanged(auth,user=>{
  if(!user){ container.innerHTML="<p>Please log in to manage appointments.</p>"; return; }
  onValue(ref(db,"establishments"),snap=>{
    container.innerHTML="";
    if(!snap.exists()){ container.innerHTML="<p>No establishments found.</p>"; return; }
    let found=false;
    snap.forEach(estSnap=>{
      const estId=estSnap.key, estData=estSnap.val();
      const ownerId = estData.ownerId || estData.uid || estData.createdBy;
      if(ownerId===user.uid){ found=true; renderEstablishmentSection(estId,estData); }
    });
    if(!found) container.innerHTML="<p>No establishments assigned to your account.</p>";
  });
});

// render
function renderEstablishmentSection(estId, estData){
  const section=document.createElement("section");
  section.className="establishment-section";
  section.id=`section_${estId}`;
  section.innerHTML=`
    <h2>${escapeHtml(estData.companyName||estData.name||"Unnamed")}</h2>
    <div class="est-meta">
      <strong>Contact:</strong> ${escapeHtml(estData.contactPerson||"-")} • ${escapeHtml(estData.phone||estData.contactNumber||"-")} • ${escapeHtml(estData.email||"-")}
      • <strong>Hours:</strong> ${escapeHtml(estData.hours||"08:00-17:00")}
    </div>
    <h3>Pending Appointment Requests</h3>
    <div id="pending_${estId}"><em>Loading pending requests...</em></div>
    <h3>Appointment Schedule (Next 2 Weeks)</h3>
    <div class="schedule">
      <table>
        <thead id="scheduleHead_${estId}"></thead>
        <tbody id="scheduleBody_${estId}"></tbody>
      </table>
    </div>
  `;
  container.appendChild(section);
  buildScheduleForEst(estId, estData.hours||"08:00-17:00");
  listenAppointmentsForEst(estId);
  listenRescheduleRequests(estId);
}

// schedule grid
function buildScheduleForEst(estId,hours){
  const { openHour, closeHour, allowedDays } = parseHours(hours);
  const startDate = new Date();
  const days=[];
  for(let i=0;i<14;i++){ const d=new Date(startDate); d.setDate(startDate.getDate()+i); if(allowedDays.includes(d.getDay())) days.push(d); }
  const headEl=document.getElementById(`scheduleHead_${estId}`), bodyEl=document.getElementById(`scheduleBody_${estId}`);
  if(!headEl||!bodyEl) return;

  let headHTML="<tr><th>Time</th>";
  days.forEach(d=>headHTML+=`<th>${d.toLocaleDateString("en-PH",{weekday:"short",month:"short",day:"numeric",timeZone:tz})}</th>`);
  headHTML+="</tr>"; headEl.innerHTML=headHTML;

  let bodyHTML=""; cellMaps[estId]={};
  for(let h=openHour;h<closeHour;h++){ for(let half=0;half<2;half++){
    const slotTime=`${String(h).padStart(2,"0")}:${half===0?"00":"30"}`;
    const timeLabel=new Date(0,0,0,h,half*30).toLocaleTimeString("en-PH",{hour:"2-digit",minute:"2-digit",hour12:true});
    bodyHTML+=`<tr><td>${timeLabel}</td>`;
    days.forEach(d=>{
      const dateKey=d.toISOString().split("T")[0];
      const cellId=`${estId}_${dateKey}_${slotTime}`;
      bodyHTML+=`<td id="${cellId}" class="empty">Available</td>`;
      cellMaps[estId][cellId]={date:dateKey,time:slotTime};
    });
    bodyHTML+="</tr>";
  }}
  bodyEl.innerHTML=bodyHTML;
}

// parse hours
function parseHours(hours){
  const m=(hours||"").match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
  const allowedDays=[1,2,3,4,5,6]; // default: closed Sunday
  return { openHour:m?parseInt(m[1],10):8, closeHour:m?parseInt(m[3],10):17, allowedDays };
}

// appointment listener
function listenAppointmentsForEst(estId){
  const pendingEl=document.getElementById(`pending_${estId}`);
  if(!pendingEl) return;
  const apptsRef=ref(db,`establishments/${estId}/appointments`);
  appointmentCache[estId]=appointmentCache[estId]||{};

  onValue(apptsRef,snap=>{
    if(!cellMaps[estId]) return;
    Object.keys(cellMaps[estId]).forEach(cid=>{
      const c=document.getElementById(cid);
      if(c){ c.className="empty"; c.textContent="Available"; c.dataset.apptKey=""; }
    });
    pendingEl.innerHTML="";
    if(!snap.exists()){ pendingEl.innerHTML="<div>No appointment requests.</div>"; appointmentCache[estId]={}; return; }

    const pendingCards=[];
    snap.forEach(aSnap=>{
      const appt=aSnap.val(), apptKey=aSnap.key; appointmentCache[estId][apptKey]=appt;
      const slots=normalizeSlots(appt.slots);

      if(["approved","accepted","confirmed","scheduled","rescheduled"].includes(appt.status)){
        slots.forEach(s=>{
          const cid=`${estId}_${s.date}_${s.time}`;
          const cell=document.getElementById(cid);
          if(cell){ cell.className="booked"; cell.textContent=`${appt.patientName||"Patient"} • ${appt.service||""}`; cell.dataset.apptKey=apptKey; }
        });
      }

      if(["pending","reschedule_requested","reschedule_request"].includes(appt.status)) pendingCards.push({apptKey,appt});
    });

    pendingCards.forEach(({apptKey,appt})=>{
      const card=document.createElement("div"); card.className="appt-card"; card.dataset.apptKey=apptKey;
      card.innerHTML=`
        <h3>${escapeHtml(appt.patientName||"Patient")}</h3>
        <div class="patient-meta"><strong>Service:</strong> ${escapeHtml(appt.service||"-")}</div>
        <div class="patient-meta"><strong>Reason:</strong> ${escapeHtml(appt.reason||"-")}</div>
      `;
      const row=document.createElement("div"); row.style.marginTop="8px";

      if(appt.status==="pending"){ row.appendChild(createButton("btn-accept","Accept",()=>startAcceptFlow(estId,apptKey,appt,card))); row.appendChild(createButton("btn-reject","Reject",()=>rejectAppointment(estId,apptKey,appt))); }
      if(appt.status && appt.status.includes("reschedule")){ row.appendChild(createButton("btn-reschedule","Approve Reschedule",()=>startRescheduleFlow(estId,apptKey,appt,card,true))); row.appendChild(createButton("btn-reject","Reject Reschedule",()=>rejectReschedule(estId,apptKey,appt))); }
      if(["approved","accepted","confirmed","scheduled"].includes(appt.status)){ row.appendChild(createButton("btn-reschedule","Reschedule",()=>startRescheduleFlow(estId,apptKey,appt,card,false))); }

      card.appendChild(row); pendingEl.appendChild(card);
    });
  });
}

// flow starters
function startAcceptFlow(estId,apptKey,appt,cardEl){
  activeSelection=[]; activeApptContext={estId,apptKey,appt,cardEl,isReschedule:false}; selectionMode="accept";
  confirmBtn.style.display="inline-block";
  showModal(`Accept appointment for ${escapeHtml(appt.patientName||"Patient")}`, `Click desired slot(s) on the grid, then click Confirm Selection.`,()=>{}, { cancelLabel:"OK", showProceed:false });
}
function startRescheduleFlow(estId,apptKey,appt,cardEl,patientRequested){
  activeSelection=[]; activeApptContext={estId,apptKey,appt,cardEl,isReschedule:true,patientRequested:!!patientRequested}; selectionMode="reschedule";
  confirmBtn.style.display="inline-block";
  showModal(patientRequested?`Approve reschedule for ${escapeHtml(appt.patientName||"Patient")}`:`Reschedule appointment`,
    `Choose ${normalizeSlots(appt.slots).length||1} slot(s). Click slots on the grid, then click Confirm Selection.`,
    ()=>{}, { cancelLabel:"OK", showProceed:false });
}

// slot selection
document.addEventListener("click",(e)=>{
  const td=e.target.closest("td"); if(!td) return; if(modalOverlay.contains(e.target)) return;
  const [estId,date,time]=td.id.split("_"); if(!estId||!date||!time) return;

  if(!activeApptContext){ if(td.classList.contains("booked") && td.dataset.apptKey){ const appt=appointmentCache[estId]?.[td.dataset.apptKey]; if(appt) openBookedOptions(estId,td.dataset.apptKey,appt); } return; }

  if(selectionMode==="accept" && activeApptContext.appt?.requestedDate){ if(date!==activeApptContext.appt.requestedDate) return; }

  toggleSlot(td.id);
});

function toggleSlot(cellId){
  const td=document.getElementById(cellId); if(!td) return;
  td.classList.toggle("outline-selected");
  if(td.classList.contains("outline-selected")) activeSelection.push(cellId);
  else activeSelection=activeSelection.filter(id=>id!==cellId);
  confirmBtn.style.display=activeSelection.length?"inline-block":"none";
}

// confirm selection
async function confirmSelection(){
  if(!activeApptContext) return;
  const { estId, apptKey, appt, isReschedule }=activeApptContext;
  if(!activeSelection.length){ alert("Select at least one slot."); confirmBtn.style.display="none"; activeApptContext=null; selectionMode=null; return; }

  const newSlots=activeSelection.map(cid=>cellMaps[estId]&&cellMaps[estId][cid]).filter(Boolean).sort((a,b)=>a.time>b.time?1:-1);
  const originalSlots=normalizeSlots(appt.slots);

  if(originalSlots.length>1){ if(newSlots.length!==originalSlots.length){ alert(`Requires exactly ${originalSlots.length} slots.`); return; } if(!areSlotsConsecutive(newSlots)){ alert("Slots must be consecutive."); return; } }
  else if(isReschedule && newSlots.length>1 && !areSlotsConsecutive(newSlots)){ alert("Slots must be consecutive."); return; }

  const slotsObj={}; newSlots.forEach((s,i)=>slotsObj[i]=s);
  const updates={}; const now=Date.now();
  updates[`establishments/${estId}/appointments/${apptKey}/slots`]=slotsObj;
  updates[`establishments/${estId}/appointments/${apptKey}/status`]=isReschedule?"rescheduled":"approved";
  updates[`establishments/${estId}/appointments/${apptKey}/${isReschedule?"rescheduledAt":"approvedAt"}`]=now;
  if(appt.patientId){ updates[`patients/${appt.patientId}/appointments/${apptKey}/slots`]=slotsObj; updates[`patients/${appt.patientId}/appointments/${apptKey}/status`]=isReschedule?"rescheduled":"approved"; const notifKey=push(ref(db,`patients/${appt.patientId}/notifications`)).key; updates[`patients/${appt.patientId}/notifications/${notifKey}`]={ type:"appointment", estId, patientName:appt.patientName||"Unknown", service:appt.service||"-", message:isReschedule?"Your appointment has been rescheduled.":"Your appointment has been accepted.", timestamp:now }; }

  try{ await update(ref(db),updates); closeModal(); activeApptContext=null; selectionMode=null; confirmBtn.style.display="none"; alert("Appointment updated successfully."); }catch(e){ console.error(e); alert("Failed to save appointment."); }
}

// cancel/reject/reschedule
async function cancelAppt(estId, apptKey, appt) {
  const reason = prompt(`Cancel appointment for ${appt.patientName || "this patient"}? Enter reason:`, "");
  if (!reason) return alert("Cancellation reason required.");

  try {
    const now = Date.now();
    const updates = {};
    updates[`establishments/${estId}/appointments/${apptKey}/status`] = "cancelled";
    updates[`establishments/${estId}/appointments/${apptKey}/cancelledReason`] = reason;
    updates[`establishments/${estId}/appointments/${apptKey}/cancelledAt`] = now;

    if (appt.patientId) {
      updates[`patients/${appt.patientId}/appointments/${apptKey}/status`] = "cancelled";
      updates[`patients/${appt.patientId}/appointments/${apptKey}/cancelledReason`] = reason;
      updates[`patients/${appt.patientId}/appointments/${apptKey}/cancelledAt`] = now;

      const notifKey = push(ref(db, `patients/${appt.patientId}/notifications`)).key;
      updates[`patients/${appt.patientId}/notifications/${notifKey}`] = {
        type: "appointment",
        estId,
        message: "Appointment cancelled by establishment",
        reason,
        timestamp: now
      };
    }

    await update(ref(db), updates);
    
    // Reset selection and modal state to prevent leftover slot selection
    activeSelection = [];
    activeApptContext = null;
    selectionMode = null;
    confirmBtn.style.display = "none";

    alert("Appointment cancelled.");
  } catch (e) {
    console.error(e);
    alert("Failed to cancel.");
  }
}

async function rejectAppointment(estId,apptKey,appt){ const reason=prompt(`Reject appointment for ${appt.patientName||"this patient"}? Enter reason:`,""); if(!reason) return alert("Rejection reason required."); try{ const now=Date.now(); const updates={}; updates[`establishments/${estId}/appointments/${apptKey}/status`]="rejected"; updates[`establishments/${estId}/appointments/${apptKey}/rejectedReason`]=reason; updates[`establishments/${estId}/appointments/${apptKey}/rejectedAt`]=now; if(appt.patientId){ updates[`patients/${appt.patientId}/appointments/${apptKey}/status`]="rejected"; updates[`patients/${appt.patientId}/appointments/${apptKey}/rejectedReason`]=reason; updates[`patients/${appt.patientId}/appointments/${apptKey}/rejectedAt`]=now; const notifKey=push(ref(db,`patients/${appt.patientId}/notifications`)).key; updates[`patients/${appt.patientId}/notifications/${notifKey}`]={ type:"appointment", estId, message:"Appointment request rejected by establishment", reason, timestamp:now }; } await update(ref(db),updates); alert("Appointment rejected."); }catch(e){ console.error(e); alert("Failed to reject."); } }
async function rejectReschedule(estId,apptKey,appt){ const reason=prompt("Reason for rejecting reschedule?"); if(!reason) return; try{ const now=Date.now(); const updates={}; updates[`establishments/${estId}/appointments/${apptKey}/status`]="approved"; updates[`establishments/${estId}/appointments/${apptKey}/rescheduleRejectedReason`]=reason; updates[`establishments/${estId}/rescheduleRequests/${apptKey}`]=null; if(appt.patientId){ updates[`patients/${appt.patientId}/appointments/${apptKey}/status`]="approved"; const notifKey=push(ref(db,`patients/${appt.patientId}/notifications`)).key; updates[`patients/${appt.patientId}/notifications/${notifKey}`]={ type:"appointment", estId, message:"Your reschedule request was rejected.", reason, timestamp:now }; } await update(ref(db),updates); alert("Reschedule rejected."); }catch(e){ console.error(e); alert("Failed to reject reschedule."); } }

// reschedule requests listener
function listenRescheduleRequests(estId){
  const reqRef=ref(db,`establishments/${estId}/rescheduleRequests`);
  onValue(reqRef,snap=>{ if(!snap.exists()) return; snap.forEach(reqSnap=>{ const req=reqSnap.val(); const apptKey=req?.appointmentId; if(!req||req.status!=="pending") return; const apptRef=ref(db,`establishments/${estId}/appointments/${apptKey}`); onValue(apptRef,apptSnap=>{ const appt=apptSnap.val(); if(!appt) return; if(appt.status==="approved") update(apptRef,{status:"reschedule_requested"}); },{onlyOnce:true}); }); });
}

// manage booked modal
function openBookedOptions(estId,apptKey,appt){
  activeApptContext={estId,apptKey,appt,cardEl:null};
  showModal(`Manage appointment`,`<b>${escapeHtml(appt.patientName||"Patient")}</b><br><small>Service: ${escapeHtml(appt.service||"-")}</small><br><br>Choose an action: Cancel or Reschedule (admin).`,()=>{}, { cancelLabel:"Cancel Appointment", showProceed:true });
  modalProceed.textContent="Reschedule";
  modalCancel.onclick=()=>{ closeModal(); cancelAppt(estId,apptKey,appt); };
  modalProceed.onclick=()=>{ closeModal(); startRescheduleFlow(estId,apptKey,appt,null,false); };
}

// modal helpers
function showModal(title,body,onAfterClose,options={}){ const {cancelLabel="OK",showProceed=false}=options; modalTitle.textContent=title; modalBody.innerHTML=`<div class="small">${body}</div>`; modalOverlay.style.display="flex"; modalOverlay.setAttribute("aria-hidden","false"); modalCancel.textContent=cancelLabel; modalCancel.style.display="inline-block"; modalProceed.style.display=showProceed?"inline-block":"none"; modalCancel.onclick=()=>{ closeModal(); if(typeof onAfterClose==="function") onAfterClose(); }; modalProceed.onclick=()=>{ if(typeof onAfterClose==="function") onAfterClose(); closeModal(); }; }
function closeModal(){ modalOverlay.style.display="none"; modalOverlay.setAttribute("aria-hidden","true"); modalBody.innerHTML=""; modalCancel.textContent="Cancel"; modalProceed.textContent="Proceed"; modalCancel.style.display="inline-block"; modalProceed.style.display="inline-block"; }

modalOverlay.addEventListener("click",e=>{ if(e.target===modalOverlay) closeModal(); });
</script>
</body>
</html>
